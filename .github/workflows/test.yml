name: Run PlayState Code

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  run-test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Haxe
        uses: krdlab/setup-haxe@v1
        with:
          haxe-version: 4.3.4

      - name: Install hjson4haxe
        run: |
          # Install or reinstall the lib
          haxelib remove hjson4haxe || true
          haxelib git hjson4haxe https://github.com/anthonydudeh/hjson4haxe

      - name: Update HJSON lib files
        run: |
          HAXELIB_DIR=$(haxelib config)/hjson4haxe/git/src

          # Overwrite HJSONWriter.hx
          cat > $HAXELIB_DIR/hjson/HJSONWriter.hx << 'EOF'
package hjson;

import Reflect;
import haxe.EReg;
import StringTools;

class HJSONWriter {
    public static function stringify(value:Dynamic, ?pretty:Bool = true, ?useCommas:Bool = false, ?indent:Int = 0):String {
        switch(Type.typeof(value)) {
            case TNull: return "null";
            case TInt, TFloat: return Std.string(value);
            case TBool: return if (value) "true" else "false";
            case TString: return escapeStringIfNeeded(value);
            case TObject: return writeObject(value, pretty, indent, useCommas);
            case TClass, TEnum, TFunction: return Std.string(value);
            default: return Std.string(value);
        }
    }

    private static function writeObject(obj:Dynamic, pretty:Bool, indent:Int, useCommas:Bool):String {
        var result = "{";
        var keys = Reflect.fields(obj);
        var sep = if(pretty) "\n" else " ";
        for(i in 0...keys.length) {
            var key = keys[i];
            var value = Reflect.field(obj, key);
            var ind = if(pretty) StringTools.repeat("  ", indent + 1) else "";
            var re = new EReg("^[a-zA-Z_][a-zA-Z0-9_]*$", "");
            var keyStr = if(re.match(key)) key else "\"" + StringTools.replace(StringTools.replace(key, "\\", "\\\\"), "\"", "\\\"") + "\"";
            result += sep + ind + keyStr + ": " + stringify(value, pretty, useCommas, indent + 1);
            if(useCommas && i < keys.length - 1) result += ",";
        }
        if(pretty && keys.length > 0) result += "\n" + StringTools.repeat("  ", indent);
        result += "}";
        return result;
    }

    private static function writeArray(arr:Array<Dynamic>, pretty:Bool, indent:Int, useCommas:Bool):String {
        var result = "[";
        var sep = if(pretty) "\n" else " ";
        for(i in 0...arr.length) {
            var value = arr[i];
            var ind = if(pretty) StringTools.repeat("  ", indent + 1) else "";
            result += sep + ind + stringify(value, pretty, useCommas, indent + 1);
            if(useCommas && i < arr.length - 1) result += ",";
        }
        if(pretty && arr.length > 0) result += "\n" + StringTools.repeat("  ", indent);
        result += "]";
        return result;
    }

    private static function escapeStringIfNeeded(str:String):String {
        var re = new EReg("^[a-zA-Z0-9_]+$", "");
        if(re.match(str)) return str;
        return "\"" + StringTools.replace(StringTools.replace(str, "\\", "\\\\"), "\"", "\\\"") + "\"";
    }
}
EOF

          # Overwrite Tokenizer.hx
          cat > $HAXELIB_DIR/hjson/tokenizer/Tokenizer.hx << 'EOF'
package hjson.tokenizer;

import StringTools;

class Tokenizer {
    public var text:String;
    public var pos:Int = 0;
    public var length:Int;

    public function new(text:String) {
        this.text = text;
        this.length = text.length;
    }

    public function nextToken():Token {
        skipWhitespace();
        if (pos >= length) return new Token(TokenType.EOF, "");
        var c = text.charAt(pos);
        return switch (c) {
            case "{": pos++; new Token(TokenType.LEFT_BRACE, "{");
            case "}": pos++; new Token(TokenType.RIGHT_BRACE, "}");
            case "[": pos++; new Token(TokenType.LEFT_BRACKET, "[");
            case "]": pos++; new Token(TokenType.RIGHT_BRACKET, "]");
            case ":": pos++; new Token(TokenType.COLON, ":");
            case ",": pos++; new Token(TokenType.COMMA, ",");
            case '"': readString();
            case 't', 'f': readBoolean();
            case 'n': readNull();
            default:
                if (isDigit(c) || c == "-") readNumber();
                else readIdentifier();
        }
    }

    private function skipWhitespace():Void {
        while (pos < length && isWhitespace(text.charAt(pos))) pos++;
    }

    private function readString():Token {
        pos++;
        var start = pos;
        while (pos < length && text.charAt(pos) != '"') {
            if (text.charAt(pos) == "\\") pos++;
            pos++;
        }
        var value = text.substring(start, pos);
        pos++;
        return new Token(TokenType.STRING, value);
    }

    private function readNumber():Token {
        var start = pos;
        while (pos < length && (isDigit(text.charAt(pos)) || text.charAt(pos) == "." || text.charAt(pos) == "-")) pos++;
        return new Token(TokenType.NUMBER, text.substring(start, pos));
    }

    private function readBoolean():Token {
        if (text.substr(pos, 4) == "true") { pos += 4; return new Token(TokenType.BOOLEAN, "true"); }
        if (text.substr(pos, 5) == "false") { pos += 5; return new Token(TokenType.BOOLEAN, "false"); }
        return readIdentifier();
    }

    private function readNull():Token {
        if (text.substr(pos, 4) == "null") { pos += 4; return new Token(TokenType.NULL, "null"); }
        return readIdentifier();
    }

    private function readIdentifier():Token {
        var start = pos;
        var stopChars = "{}[]:,";
        while (pos < length && !isWhitespace(text.charAt(pos)) && StringTools.indexOf(stopChars, text.charAt(pos)) == -1) pos++;
        return new Token(TokenType.IDENTIFIER, text.substring(start, pos));
    }

    private function isDigit(c:String):Bool {
        return c >= "0" && c <= "9";
    }

    private function isWhitespace(c:String):Bool {
        return c == " " || c == "\n" || c == "\r" || c == "\t";
    }
}
EOF

      - name: List haxelib
        run: haxelib list

      - name: Run PlayState.hx
        run: |
          haxe -cp source -cp $(haxelib config)/hjson4haxe/git/src -main PlayState --interp
